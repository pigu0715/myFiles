vpn
17349138242
s94y07t15!Aa

svn:
zhangtw/Tydic@23#!23

#pms_exe/jyI/,O7y39
#pms_sys/p7S7Va#6K^

主机 DCA命令
hset plca.cache HALT_CREDIT_SPECIAL_SWITCH 0    
hgetall plca.cache 
hget plca.cache HALT_CREDIT_SPECIAL_SWITCH
   
关于索引：
1.主键自动建立唯一索引；
2.频繁作为查询条件的字段应该创建索引；
3.查询中与其他表有关联的字段，例如外键关系；
4.频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件；
5.where条件里用不到的字段，不创建索引；
6.高并发的情况下一般选择复合索引；
7.查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找）；
8.查询中统计或者分组的字段；
9.表记录太少，不需要创建索引；
10.经常增删改的表；
11.数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引。

1.hashMap实现原理
	数组+链表+红黑树
2.索引的数据结构
	B+Tree
3.http请求的过程
	1)建立TCP连接 2) 客户端发送请求 3)服务端响应请求 4)服务端关闭连接
4.消息队列如何保证消息不会丢失
	在生产阶段，你需要捕获消息发送的错误，并重发消息。
	在存储阶段，你可以通过配置刷盘和复制相关的参数，让消息写入到多个副本的磁盘上，来确保消息不会因为某个 Broker 宕机或者磁盘损坏而丢失。
	在消费阶段，你需要在处理完全部消费业务逻辑之后，再发送消费确认。
5.消息队列如何保证消息不会重复消费
	消费端幂等性处理-》 可以使用数据库唯一约束实现 或者为更新的数据设置条件的方法

--volatile
volatile 修饰变量 当前jvm寄存器中的值是不可靠的，需要去内存中读取
volatile 可以保证可见性 不能保证原子性 
volaitle 不会线程阻塞 

--synchronized
synchronized 锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
synchronized 可以保证变量的修改可见性和原子性
synchronized 会线程阻塞

Transaction注解的方法
1.必须是public的
2.必须通过代理过的类从外部调用的
3.默认回滚的是RuntimeException和Error

java设计模式 构建者模式 优点
1.保证对象的状态一致性（在build()之前保证对象不被创建）
2.提高代码的可读性
